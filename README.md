# fe-shopping

- [x] 검색창 관련 모듈 개발
- [x] 프로토타입 / 클래스 혼용
- [X] SCSS 및 마크업
- [X] 자동 캐러셀 이벤트
- [] 카테고리 드롭다운 애니메이션
-  [] 검색창 방향키 탐색기능


### 설계

모든 웹페이지를 컴포넌트화된 뷰로써 렌더링하고, 각 뷰는 내부에 템플릿을 가지도록 한다. 

- 뷰는 생성되면서 참조할 상태를 안고 태어나고, 뷰에 존재하는 부모-자식 관계를 위해서 parent라는 포인터를 다른 뷰에 가진다. 
- 같은 부모를 가리키는 뷰는 next 포인터로 연결된 하나의 노드가 된다. 
- 외부에서 전역 상태를 관리할 Store 인스턴스를 생성하면서, 가장 상위 App 노드를 자신의 #head 노드로 지정한다. stack을 이용하는 visitor 클래스를 의존성으로 가지고,
head 노드부터 연결된 모든 컴포넌트 노드들의 상태를 전역 상태로 밀어넣는다. 

### 렌더링

모든 렌더링은 각 컴포넌트에서 자신의 뷰에서 참조하는 상태를 setState으로 변경하면 발생한다. setState이 일어난 컴포넌트만 렌더링 여부를 알리는 #willRender 플래그가 true로 바뀌고, store에서는
자신의 헤더노드에 render 명령을 내리면 Chainable Responsibility 패턴을 사용해서 연결된 모든 자식과 형제 노드의 render를 전부 순회하면서 실행하는데, 이 때 setState가 일어나서 #willRender가 true인 컴포넌트만 렌더링 된다.
각 컴포넌트는 throttle이나 debounce 등의 이벤트 최척화를 위한 EventHandler 클래스 객체를 의존성으로 갖고 있으며, 렌더링 및 발생 이벤트를 각각의 eventHandler가 debounce로 프레임 최적화한다. 

### 고민

현재 각 컴포넌트에 각각 프레임 최적화를 위한 핸들러가 할당되어 있어서 requestAnimationFrame이 컴포넌트의 수만큼 존재하는데, 이것보다는 하나의 애니메이션 프레임에 여러 컴포넌트의 렌더링 콜백을 밀어넣는 것이
더 부하가 덜하다고 알고 있습니다. 이렇게 최적화를 하기 위해서 설계를 조금 변경해야 할 것 같습니다.

### 미구현한 점

설계를 재설계하느라 카테고리 드롭다운이나 검색창 방향키 선택 등의 이벤트를 아직 미구현하였음.