# step1

## 진행 사항
1. 기본 마크업
    -   이번 주 미션이 진행되는 헤더부분과 캐로셀 부분 마크업 작업을 먼저 진행했습니다. index.html에 우선 뼈대 작성 후 컴포넌트 JS파일을 만들면 index.html에서 지워주는 순서로 작업 중입니다.
2. carousel 기능 구현
    -   캐로셀을 지난 카카오 미션 때 해봤었기 때문에 익숙하여 먼저 구현했습니다...만 결과적으로 카카오 때와는 동작방식이 달라 새롭게 코드를 작성했습니다.
    -   썸네일에 마우스오버시 오토슬라이드를 정지하였는데 UX를 고려하면 썸네일이 아닌 캐로셀에 마우스가 올라오면 정지하는 것이 바람직할 것 같습니다.

## 고민한 부분, 어려웠던 점
1. scss
    -   scss를 처음 사용했는데 익숙치가 않아 좋다는 느낌을 많이 받지 못했습니다. mixin 기능을 사용해보고 싶은데 아직 적용하지 못했습니다. 
    -   scss로 중첩을 쉽게할수 있는 것은 좋은데 오히려 indent가 너무 깊어지는 상황(_header.scss)이 발생했습니다. 
    잘하시는 분들이 어떻게 하셨나 참고할 필요가 있을 것 
    같습니다.

2. class의 Private 속성
    -   함수로 모듈을 구성할 때는 export로 원하는 함수만 공개할 수 있었기 때문에 class에서는 어떤 식으로 원하는 것만 노출시킬까 찾아보다가 # prefix로 private 속성을 적용해 보았습니다.
    -   사용자가 함부로 내부 로직에 영향을 줄 수 없게 한다는 점에서 좋은 것 같긴한데.. 혼자하는 초소형 프로젝트라 직접적으로 유용함을 느끼진 못했습니다. 약간 마음이 편안해지는 효과..?

3. 오토슬라이드 멈추기
    -   지난 카카오 미션에서 슬라이드 위로 마우스를 여러번 올리고 내리면 eventListener가 여러번 호출되어 슬라이드를 넘기는 timeInterval이 여러개 생겨 한번에 여러장이 넘어가는 버그가 있었습니다.
    -   이번엔 클래스를 이용하기 때문에 전역변수 없이 intervalID를 저장하고 이미 수행중인 것이 있으면 재등록하지 않는 방식으로 문제를 해결했습니다...
    -   ...만 어쨌든 이벤트처리 자체는 여러번 수행하는 것이기 때문에 근본적으로 이벤트가 중복발생하지 않도록 하는  방법을 생각해봐야겠습니다. 

## 이후 계획
원래는 익숙한 캐로셀을 후딱 구현하고 이번 주의 핵심인 검색창 부분을 prototype을 사용하여 구현할 계획이었는데 시간이 생각보다 오래걸렸습니다...

    0. 이번 PR의 리뷰 반영
    1. prototype 학습 및 적용
    2. 검색창 부분 미션 구현
    3. scss 리팩토링

순으로 다음 PR까지 진행하려 합니다. 


# step2

## 기능 구현 목록

### 검색 카테고리
-   [x] 클릭시 카테고리 펼쳐지기(애니메이션)
-   [x] 카테고리 목록 클릭시 해당 카테고리를 상단에 등록
-   [ ] 키보드로 조작

### 최근 검색어
-   [x] 입력창 선택시 최근검색어창 열기
-   [x] submit시 최근검색에 등록
-   [x] 전체삭제기능
-   [x] 최근 검색어 클릭시 입력창에 반영
-   [ ] 최근검색어끄기 기능
-   [ ] 키보드로 조작

### 자동완성
-   [x] 검색어 입력시 자동완성 기능 시작
-   [x] 500ms debounce
-   [x] 아마존 자동완성 서버로부터 데이터 fetch
-   [ ] 키보드로 조작
-   [ ] 추천 검색어 클릭시 입력창에 반영

## 캐로셀
-   [x] 자동 화면 전환
-   [x] 썸네일에 mouse hover시 전환
-   [ ] 썸네일 이벤트에 debounce 걸기
  
## 프로그래밍 요구사항 수행 목록
-   [x] ES Classes 기반 객체를 한 개 이상 만든다
-   [x] prototype 기반 객체를 한 개 이상 만든다. --> renderer에만 적용...
-   [x] 검색창 관련된 모듈을 하나의 객체로 하지 않고 여러개의(2개이상) 객체로 나눠서 개발
-   [x] 컴포넌트 나눠 상속 받아 사용 --> dropdown class 상속받아 사용
-   [ ] scss 중첩 및 mixin 사용 --> 일부에만 적용. 리팩토링 필요
-   [ ] prototype 사용한 상속 



## 구현하며 신경쓴 점 (의도)

1. 전반적인 구현 과정
    -   지난 미션까지는 구조 설계나 컴포넌트 나누는 것에 시간을 많이 썼습니다. 이번에도 역시 그렇게 시작했으나 고민을 계속한다고 해서 깔끔한 정답을 얻기에는 아직 실력이 부족하다고 생각해서 이번에는 방식을 바꿔봤습니다. 
    -   큰 틀에서 구현해야하는 기능을 꼬리를 물며 정리했고 필요한 함수 목록을 이름만 먼저 작성한 뒤 구조를 나누지 않고 일단 코드를 작성했습니다.
    -   그 이후 중복되는 부분이 발생하거나 하나의 클래스가 너무 많은 역할을 한다고 생각될 때 분리하여 새로운 하위 컴포넌트를 정의했습니다.
    -   그렇게하다보니 Search에서 SearchCategory와 SearchMain이 분리되고, SearchMain에서 필요한 기능을 RecentSearchList와 AutoComplete로 꺼내 따로 정의하게 되었습니다.
    -   장점(느낌)
        -   직접 필요를 느끼며 구조를 만든 것이라서 나름의 논리가 생겨 뒤로 갈수록 코드 짜는것이 수월했습니다. 
        -   이전에는 분명 제가 짠 코드인데 '어? 이 함수 어디다 뒀더라' 하던 때도 있었는데 이번에는 있을만한 곳에 가보면 그 함수가 있는 느낌... 
    -   단점
        -   더 좋은 방법을 찾으려면 나름대로 노력했는데도 문제가 있음을 깨닫고 다른 사람은 어떻게 했는지 찾아야합니다. 재밌고 좋은 학습법이라고 생각하지만 패턴을 공부하고 '정석'대로 짜려할 때보다 오래걸리는 것 같습니다.
        -   필요를 느낄 때마다 분리하다보니 일을 두 번하는 느낌도 들고, 덜 나눠진 부분들이 존재합니다.  

2. 모듈이란?
    -   '위 방법대로 구현하면서 모듈이란 무엇일까?' '어떻게 모듈을 나누고 정의해야할까?'를 고민했습니다.
    -   이번 미션을 진행하며 모듈은 커다란 공동 목표를 위해 모인 회사원과 비슷하다고 느꼈습니다.
    
    1. 각 모듈(회사원)은 적절한 양의 명확한 역할을 맡아야한다.
    2. 상위 모듈(간부)는 하위 모듈(부하)의 세세한 동작을 알거나 지시할 필요없이 큰 틀에서 작업을 명령해야(할수 있어야)한다.
        -   상위 모듈의 역할은 data를 받아와 class에 넘겨줌으로서 instacne를 정의하고 작업지시는 instance.template, instance.activate()등으로 큰틀에서만 진행.
    3. 단, 하위모듈(팀)에 속한 모듈(팀원)들끼리는 보다 많은 것을 공유할 수도 있다.
        -   서로 정보를 주고받아야하는 부분이 있으므로 최상위에게 getTemplate(), activate()만 오픈하는 것에 비하면 많은 동작을 서로 공유한다.
        -   그렇다하더라도 최대한 필요한 부분만 노출하고 내부 작업은 숨긴다.
    
3. Private
    -   위와 같이 나름 정의한 모듈을 만들기 위해class의 Private 기능을 일부러 사용했습니다.
    -   이 모듈이 마땅히 수행해야하는 동작을 먼저 생각해 본 후 public method로 이름지은 후 내부 동작은 전부 private으로 구현했습니다.
    -   그렇게 모듈을 만들어 사용하는 중 public으로 제공하는 것 외에 내부 사정을 건드리고 싶어지는 상황이 발생하면...
        1. 사용하는 곳과 사용 중인 모듈의 역할이 명확하게 나뉘지 않아서 서로 내부 사정을 들여다보고 싶은 것이다.
        2. 사용 중인 모듈의 역할 정의가 명확하지 않았다.
    -   위 둘중에 하나라고 생각하여, 잠시 멈추고 모듈의 역할을 다시 정리했습니다.

## 정리
위 사항들은 처음부터 정리되어 코드를 작성할 때 반영된 것이 아니고, 코드를 작성하다보니 '이러이러한 원칙들을 지킬 필요가 있겠구나..'라고 느낀 것을 정리한 것입니다. 그래서 실제 코드에는 완벽히 지켜지지 못했습니다. 위 내용은 이번 일주일동안 들었던 생각이기 때문에 앞으로 다른 사람들 코드도 많이 보고 토론도 하며 생각을 발전시켜봐야겠습니다. 이번주에 핵심 주제 중 하나였던 prototype 또한 코드에 많이 사용하지 못해 주말동안엔 prototype을 좀 더 공부해볼 예정입니다.

감사합니다! 

# step3

## 기능 구현 목록

### 카테고리 메뉴
-   [x] 카테고리 버튼에 마우스 올리면/내리면 메뉴 등장/숨김
-   [x] 1차메뉴에 마우스 올리면 그에 맞는 2차메뉴 등장
-   [x] 1차메뉴에서 2차메뉴로 이동시 대각선 이동 지원(smart menu layer) --> 버그 존재
-   [ ] 레이아웃 css 작업
-   [ ] 3차 메뉴 구현

### 검색창 (지난주 요구사항)
-   [x] 키보드로 조작 --> 위아래 방향키로 검색어 이동가능
-   [ ] 최근검색어끄기 기능

## 프로그래밍 요구사항 수행 목록
-   [x] 스마트 메뉴 레이어는 setTimeout을 잘 활용해서 debounce 나 throttling 방식을 사용한다
-   [x] Store를 View영역에서 분리한다. (Category 한정)
-   [ ] 지난 주에 구현한 컴포넌트 파일에서 store와 view를 분리. 단 나만의 철학을 지키며. 

## Smart Menu Layer (UX)

### 개요

-   스마트 메뉴 레이어는 1차 레이어에서 2차 레이어로 마우스 이동시 레이어 칸을 벗어나지 않게 수직으로 이동할 필요 없이 대각선 이동을 지원하는 것. (참고 사이트 : https://story.pxd.co.kr/655 )
-   기존의 쿠팡 카테고리에는 이 기능이 '일부' 적용되어 있었다!
    -   1차 레이어에서 2차 레이어로 북동쪽 방향으로 커서를 이동하면 스마트 레이어 기능이 적용되어 다른 2차 레이어로의 전환없이 원하는 레이어에 도달할 수 있었다.
    -   그런데 남동쪽 방향으로 커서를 이동할 때는 스마트레이어 기능이 없어 수평방향으로 잘 움직여야 원하는 레이어로 이동가능하다.
    -   도대체 왜 이렇게 해놨을까? 깜빡한걸까?

### 구현 방법
1. Debounce
    -   mouse event에 debounce를 걸어 이벤트가 계속 발생하고 있을 때는 반영(2차 레이어 render)하지 않다가 이벤트 발생이 더 이상 없을 때 반영해주는 방법을 생각해 보았습니다.
    -   이 방법은 1차 레이어에서 2차 레이어 쪽으로 대각선 이동할 때는 유용하게 작동하지만, 1차 레이어안에서 마우스를 움직일 때는 불필요한 지연이 발생해 나쁜 UX를 줄수 있다고 생각했습니다.

2. 마우스 방향 감지
    -   크롱이 아마존에서 이런 방식을 사용했다고 하셔서 방식을 따라해봤습니다.
    -   펼쳐져 있는 2차 레이어의 상하단 끝점과 기존 커서 위치를 이용해 삼각형을 만들고 이동한 커서가 삼각형 안에 있으면 해당 2차레이어로 이동하고 있다고 판단합니다.
    -   위와 같이 판단시에는 마우스가 이동한 1차 메뉴의 2차 레이어를 바로 render하지 않고 delay를 줍니다.
    -   delay 이내에 2차 레이어로 이동하면 대기 중이던 render를 취소하고, 여전히 1차 레이어에 머물고 있다면 해당 1차 메뉴에 맞는 2차 레이어를 render해줍니다.

### 구현 결과

(동영상)

현재 삼각형 밖으로 커서를 이동시켰는데도 가끔 삼각형 안으로 계산하여 delay가 적용되는 버그가 있습니다. 2차원에서 벡터 외적과 삼각형 내부 판별을 간이로 수행했기 때문에 발생한 버그인지, 로직 순서상의 버그인지 아직 모르겠습니다. 시간이 되면 버그를 찾아보려 합니다. 

## Model - View 분리

    지난주에 작성했던 components 파일들을 먼저 리팩토링하는 대신 이번주에 새롭게 구현한 Category 기능을 Model View 그리고 Category로 나눠서 작성해봤습니다.

### 1. Model
    -   필요한 data를 fetch
    -   data를 분석하여 정리
    -   다른 데이터를 가져가 사용할 수 있게 호출 API 제공

Category의 경우 Model의 역할이 많지 않았습니다. 사실 서버에서 데이터를 제공하는 형태가 조금만 잘 정리되어 있었더라면 Model을 굳이 따로 둘 필요 없이 필요한 데이터를 바로 fetch받아와 사용해도 될것 같다는 생각이 들었습니다. (그래서 이번엔 일부러 서버의 json에는 그냥 데이터를 뭉쳐두고 Model에서 parse라도 하게 역할을 줬습니다.)

지난 주에 구현했던 다른 컴포넌트들도 Search data를 추가 제거하며 관리해야하는 RecentSearchList를 제외하고는 Model이 할일이 별로 없을 것 같아 '굳이 나눠야 하는가?'라는 고민을 하고 있습니다. 

### 2. View
    -   제공 받은 data를 사용해 적절한 DOM template를 생성

Model에 대한 의존성을 없애기 위해 View는 Model을 알지 못하게 했습니다. 그래서 event 발생에 따라 다른 data를 이용해 view를 render해야하는 경우 해당 event 처리는 전부 controller에서 해줬습니다. 그랬더니 View 또한 역할이 굉장히 컴팩트 해졌습니다. 반대급부로 Controller가 커졌기 때문에 data와 관계없는 event(ex. 마우스가 떠나면 카테고리 메뉴 접기)들은 view에서 처리해줘도 되겠다는 생각을 했습니다.

### 3. Controller
    -   사용자 입력을 접수하고 반응
    -   model에서 데이터 요청하여 view에게 제공, view로부터 전달받은 template를 DOM tree에 등록

데이터 관리와 template 생성을 제외한 모든 역할을 맡았습니다.
위에 설명한대로 controller의 역할이 너무 많아 가독성이 떨어지는 것 같습니다. 일부를 view에게 넘기거나, controller를 분리하고 싶다는 생각을 했습니다.

# step3

구현 중 발생한 고민:
view -> vm -> model 순서로만 알고 있음.
view는 어떠어떠하게 상세하게 지도하지 않고 그냥 이벤트 발생했어! vm아 처리해줘! 하고 싶어 
근데 처리결과에 따라 render를 다르게 하고 싶어.. 처리를 하고나면 model이 바뀌어. 근데 그걸 어케 사용하지?
--> 콜백 펑션을 넘겨줘야하나? ㄴㄴ 그조차도 안하고 싶으면 옵저버 패턴이라는걸 사용해보자!
--> vm은 view가 보여줘야할 데이터를 가지고 있는다 --> 상태로 가지고 있는다. 그 상태와 데이터가 갱신될때 notify를 해주자