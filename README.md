# step1

## 진행 사항
1. 기본 마크업
    -   이번 주 미션이 진행되는 헤더부분과 캐로셀 부분 마크업 작업을 먼저 진행했습니다. index.html에 우선 뼈대 작성 후 컴포넌트 JS파일을 만들면 index.html에서 지워주는 순서로 작업 중입니다.
2. carousel 기능 구현
    -   캐로셀을 지난 카카오 미션 때 해봤었기 때문에 익숙하여 먼저 구현했습니다...만 결과적으로 카카오 때와는 동작방식이 달라 새롭게 코드를 작성했습니다.
    -   썸네일에 마우스오버시 오토슬라이드를 정지하였는데 UX를 고려하면 썸네일이 아닌 캐로셀에 마우스가 올라오면 정지하는 것이 바람직할 것 같습니다.

## 고민한 부분, 어려웠던 점
1. scss
    -   scss를 처음 사용했는데 익숙치가 않아 좋다는 느낌을 많이 받지 못했습니다. mixin 기능을 사용해보고 싶은데 아직 적용하지 못했습니다. 
    -   scss로 중첩을 쉽게할수 있는 것은 좋은데 오히려 indent가 너무 깊어지는 상황(_header.scss)이 발생했습니다. 
    잘하시는 분들이 어떻게 하셨나 참고할 필요가 있을 것 
    같습니다.

2. class의 Private 속성
    -   함수로 모듈을 구성할 때는 export로 원하는 함수만 공개할 수 있었기 때문에 class에서는 어떤 식으로 원하는 것만 노출시킬까 찾아보다가 # prefix로 private 속성을 적용해 보았습니다.
    -   사용자가 함부로 내부 로직에 영향을 줄 수 없게 한다는 점에서 좋은 것 같긴한데.. 혼자하는 초소형 프로젝트라 직접적으로 유용함을 느끼진 못했습니다. 약간 마음이 편안해지는 효과..?

3. 오토슬라이드 멈추기
    -   지난 카카오 미션에서 슬라이드 위로 마우스를 여러번 올리고 내리면 eventListener가 여러번 호출되어 슬라이드를 넘기는 timeInterval이 여러개 생겨 한번에 여러장이 넘어가는 버그가 있었습니다.
    -   이번엔 클래스를 이용하기 때문에 전역변수 없이 intervalID를 저장하고 이미 수행중인 것이 있으면 재등록하지 않는 방식으로 문제를 해결했습니다...
    -   ...만 어쨌든 이벤트처리 자체는 여러번 수행하는 것이기 때문에 근본적으로 이벤트가 중복발생하지 않도록 하는  방법을 생각해봐야겠습니다. 

## 이후 계획
원래는 익숙한 캐로셀을 후딱 구현하고 이번 주의 핵심인 검색창 부분을 prototype을 사용하여 구현할 계획이었는데 시간이 생각보다 오래걸렸습니다...

    0. 이번 PR의 리뷰 반영
    1. prototype 학습 및 적용
    2. 검색창 부분 미션 구현
    3. scss 리팩토링

순으로 다음 PR까지 진행하려 합니다. 


# step2

## 기능 구현 목록

### 검색 카테고리
-   [x] 클릭시 카테고리 펼쳐지기(애니메이션)
-   [x] 카테고리 목록 클릭시 해당 카테고리를 상단에 등록
-   [ ] 키보드로 조작

### 최근 검색어
-   [x] 입력창 선택시 최근검색어창 열기
-   [x] submit시 최근검색에 등록
-   [x] 전체삭제기능
-   [x] 최근 검색어 클릭시 입력창에 반영
-   [ ] 최근검색어끄기 기능
-   [ ] 키보드로 조작

### 자동완성
-   [x] 검색어 입력시 자동완성 기능 시작
-   [x] 500ms debounce
-   [x] 아마존 자동완성 서버로부터 데이터 fetch
-   [ ] 키보드로 조작
-   [ ] 추천 검색어 클릭시 입력창에 반영

## 캐로셀
-   [x] 자동 화면 전환
-   [x] 썸네일에 mouse hover시 전환
-   [ ] 썸네일 이벤트에 debounce 걸기
  
## 프로그래밍 요구사항 수행 목록
-   [x] ES Classes 기반 객체를 한 개 이상 만든다
-   [x] prototype 기반 객체를 한 개 이상 만든다. --> renderer에만 적용...
-   [x] 검색창 관련된 모듈을 하나의 객체로 하지 않고 여러개의(2개이상) 객체로 나눠서 개발
-   [x] 컴포넌트 나눠 상속 받아 사용 --> dropdown class 상속받아 사용
-   [ ] scss 중첩 및 mixin 사용 --> 일부에만 적용. 리팩토링 필요
-   [ ] prototype 사용한 상속 



## 구현하며 신경쓴 점 (의도)

1. 전반적인 구현 과정
    -   지난 미션까지는 구조 설계나 컴포넌트 나누는 것에 시간을 많이 썼습니다. 이번에도 역시 그렇게 시작했으나 고민을 계속한다고 해서 깔끔한 정답을 얻기에는 아직 실력이 부족하다고 생각해서 이번에는 방식을 바꿔봤습니다. 
    -   큰 틀에서 구현해야하는 기능을 꼬리를 물며 정리했고 필요한 함수 목록을 이름만 먼저 작성한 뒤 구조를 나누지 않고 일단 코드를 작성했습니다.
    -   그 이후 중복되는 부분이 발생하거나 하나의 클래스가 너무 많은 역할을 한다고 생각될 때 분리하여 새로운 하위 컴포넌트를 정의했습니다.
    -   그렇게하다보니 Search에서 SearchCategory와 SearchMain이 분리되고, SearchMain에서 필요한 기능을 RecentSearchList와 AutoComplete로 꺼내 따로 정의하게 되었습니다.
    -   장점(느낌)
        -   직접 필요를 느끼며 구조를 만든 것이라서 나름의 논리가 생겨 뒤로 갈수록 코드 짜는것이 수월했습니다. 
        -   이전에는 분명 제가 짠 코드인데 '어? 이 함수 어디다 뒀더라' 하던 때도 있었는데 이번에는 있을만한 곳에 가보면 그 함수가 있는 느낌... 
    -   단점
        -   더 좋은 방법을 찾으려면 나름대로 노력했는데도 문제가 있음을 깨닫고 다른 사람은 어떻게 했는지 찾아야합니다. 재밌고 좋은 학습법이라고 생각하지만 패턴을 공부하고 '정석'대로 짜려할 때보다 오래걸리는 것 같습니다.
        -   필요를 느낄 때마다 분리하다보니 일을 두 번하는 느낌도 들고, 덜 나눠진 부분들이 존재합니다.  

2. 모듈이란?
    -   '위 방법대로 구현하면서 모듈이란 무엇일까?' '어떻게 모듈을 나누고 정의해야할까?'를 고민했습니다.
    -   이번 미션을 진행하며 모듈은 커다란 공동 목표를 위해 모인 회사원과 비슷하다고 느꼈습니다.
    
    1. 각 모듈(회사원)은 적절한 양의 명확한 역할을 맡아야한다.
    2. 상위 모듈(간부)는 하위 모듈(부하)의 세세한 동작을 알거나 지시할 필요없이 큰 틀에서 작업을 명령해야(할수 있어야)한다.
        -   상위 모듈의 역할은 data를 받아와 class에 넘겨줌으로서 instacne를 정의하고 작업지시는 instance.template, instance.activate()등으로 큰틀에서만 진행.
    3. 단, 하위모듈(팀)에 속한 모듈(팀원)들끼리는 보다 많은 것을 공유할 수도 있다.
        -   서로 정보를 주고받아야하는 부분이 있으므로 최상위에게 getTemplate(), activate()만 오픈하는 것에 비하면 많은 동작을 서로 공유한다.
        -   그렇다하더라도 최대한 필요한 부분만 노출하고 내부 작업은 숨긴다.
    
3. Private
    -   위와 같이 나름 정의한 모듈을 만들기 위해class의 Private 기능을 일부러 사용했습니다.
    -   이 모듈이 마땅히 수행해야하는 동작을 먼저 생각해 본 후 public method로 이름지은 후 내부 동작은 전부 private으로 구현했습니다.
    -   그렇게 모듈을 만들어 사용하는 중 public으로 제공하는 것 외에 내부 사정을 건드리고 싶어지는 상황이 발생하면...
        1. 사용하는 곳과 사용 중인 모듈의 역할이 명확하게 나뉘지 않아서 서로 내부 사정을 들여다보고 싶은 것이다.
        2. 사용 중인 모듈의 역할 정의가 명확하지 않았다.
    -   위 둘중에 하나라고 생각하여, 잠시 멈추고 모듈의 역할을 다시 정리했습니다.

## 정리
위 사항들은 처음부터 정리되어 코드를 작성할 때 반영된 것이 아니고, 코드를 작성하다보니 '이러이러한 원칙들을 지킬 필요가 있겠구나..'라고 느낀 것을 정리한 것입니다. 그래서 실제 코드에는 완벽히 지켜지지 못했습니다. 위 내용은 이번 일주일동안 들었던 생각이기 때문에 앞으로 다른 사람들 코드도 많이 보고 토론도 하며 생각을 발전시켜봐야겠습니다. 이번주에 핵심 주제 중 하나였던 prototype 또한 코드에 많이 사용하지 못해 주말동안엔 prototype을 좀 더 공부해볼 예정입니다.

감사합니다! 




